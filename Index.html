<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streams Sphere IPTV Player</title>
    <!-- HLS.js for streaming -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <!-- YouTube IFrame API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ELEK5MC4D5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-ELEK5MC4D5');
    </script>
    
    <style>
        /* Aurora Glass Theme */
        :root {
            --bg-color: #0a0a14;
            --text-color: #f0f0f5;
            --text-muted: #a0a0b0;
            --accent-color: #8A2BE2; /* BlueViolet */
            --accent-glow: rgba(138, 43, 226, 0.5);
            --glass-bg: rgba(20, 20, 35, 0.55);
            --border-color: rgba(138, 43, 226, 0.2);
        }

        html, body {
            overflow: hidden;
            height: 100%;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #0d042f, #2c135c, #0a192f, #3d2f7b);
            color: var(--text-color);
            background-size: 400% 400%;
            animation: aurora-flow 20s ease infinite;
        }

        @keyframes aurora-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .hidden { display: none; }

        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 4px; }

        .glass-ui {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--border-color);
        }

        header, #sidebar {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-color: var(--border-color);
        }

        #player-container {
            box-shadow: 0 0 25px var(--accent-glow), 0 0 10px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }

        .header-title {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 10px var(--accent-glow), 0 0 2px rgba(0,0,0,0.5);
            animation: pulse-text-glow 3s infinite ease-in-out;
        }
        
        .channel-item.active {
            background-color: rgba(138, 43, 226, 0.3);
            color: white;
            animation: pulse-aurora 2s infinite;
        }
        
        @keyframes pulse-aurora {
            0% { box-shadow: 0 0 0 0 var(--accent-glow); }
            70% { box-shadow: 0 0 0 10px rgba(138, 43, 226, 0); }
            100% { background-color: var(--accent-color); box-shadow: 0 0 0 0 rgba(138, 43, 226, 0); }
        }

        .channel-item.active .channel-title, .channel-item.active .text-slate-400 {
            color: white;
        }

        .channel-item:hover, .category-item:hover { background-color: rgba(138, 43, 226, 0.2); }

        .favorite-btn.favorite { color: var(--accent-color); }

        .custom-input, .custom-btn, .custom-link-btn {
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 0.5rem;
            outline: none;
            transition: all 0.2s ease-in-out;
        }

        .custom-input:focus, .custom-btn:focus, .custom-link-btn:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-glow);
        }
        
        .custom-btn, .custom-link-btn {
            background-color: var(--accent-color);
            color: white;
        }
        
        .custom-btn:hover, .custom-link-btn:hover {
            background-color: rgba(138, 43, 226, 0.8);
            text-decoration: none;
        }

        #sidebar { transition: transform 0.3s ease-in-out; }

        .loader {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #source-selector-dropdown {
            border: 1px solid rgba(138, 43, 226, 0.5);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        
        #youtube-player-container, #youtube-player-div {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .dvd-case {
            position: relative;
            background: linear-gradient(45deg, #1e103f, #0a0a14);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3), 0 0 5px var(--accent-glow);
        }

        .dvd-case:hover {
            transform: scale(1.05) perspective(1000px) rotateY(2deg);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5), 0 0 20px var(--accent-glow);
        }

        .dvd-case-img-container {
            aspect-ratio: 2 / 3;
            background-color: #1a1a2e;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .dvd-case-img-container::after { /* Inner shadow for depth */
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
        }

        .dvd-case-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .dvd-case:hover .dvd-case-img { transform: scale(1.1); }

        .dvd-case-title {
            padding: 0.75rem 0.5rem;
            font-size: 0.8rem;
            font-weight: 500;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            background: linear-gradient(to top, rgba(0,0,0,0.7), rgba(0,0,0,0.4));
            border-top: 1px solid var(--border-color);
        }

        .dvd-case::before {
            content: '';
            position: absolute;
            top: 0;
            left: -85%;
            z-index: 2;
            display: block;
            width: 50%;
            height: 100%;
            background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 100%);
            transform: skewX(-25deg);
            transition: left 0.7s ease;
        }
        .dvd-case:hover::before { left: 110%; }

        .back-button {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
    </style>
</head>
<body class="bg-slate-900">

<div class="relative h-full w-full flex flex-col">
    <!-- Header -->
    <header class="w-full border-b flex items-center justify-between p-2 z-20 flex-shrink-0">
        <div class="flex items-center space-x-4">
            <button id="menu-toggle" class="md:hidden p-2 text-slate-400 hover:text-purple-400 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
            </button>
            <div class="flex items-center space-x-3">
                <img id="logo" src="https://images.weserv.nl/?url=iili.io/Fg2td42.png" alt="Streams Sphere Logo" class="h-10 w-auto">
                <span class="text-xl font-bold text-white header-title">Streams Sphere</span>
            </div>
        </div>
        <div class="flex items-center space-x-2">
             <a href="https://www.paypal.com/donate/?business=adambriggs2022@gmail.com&no_recurring=0&currency_code=GBP&item_name=Support+Streams+Sphere+TV" target="_blank" id="buy-coffee-btn" class="p-2 text-sm custom-link-btn flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line></svg>
                <span class="hidden sm:inline">Buy me a Coffee</span>
            </a>
            <button id="feedback-btn" class="p-2 text-sm custom-btn flex items-center space-x-2">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                <span class="hidden sm:inline">Feedback</span>
            </button>
            <button id="about-btn" class="p-2 text-sm custom-btn flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                <span class="hidden sm:inline">About</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden min-h-0">
        <!-- Sidebar -->
        <aside id="sidebar" class="absolute md:relative top-0 left-0 h-full w-64 md:w-72 border-r flex flex-col z-30 transform -translate-x-full md:translate-x-0 flex-shrink-0 min-h-0">
            <div class="p-4 border-b border-[var(--border-color)]">
                <div id="custom-select-container" class="relative">
                    <button id="source-selector-button" class="w-full p-2 custom-input flex items-center justify-between text-left">
                        <span class="flex items-center space-x-2 truncate">
                            <span id="source-selector-icon"></span>
                            <span id="source-selector-text">Select a Playlist</span>
                        </span>
                        <svg class="w-4 h-4 text-slate-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </button>
                    <div id="source-selector-dropdown" class="absolute hidden mt-1 w-full glass-ui rounded-md shadow-lg z-40 flex flex-col">
                        <div class="p-2 border-b border-[var(--border-color)] space-y-2">
                            <input type="text" id="playlist-search-input" placeholder="Search playlists..." class="w-full p-2 custom-input text-sm">
                             <button id="add-playlist-btn" class="w-full p-2 text-sm custom-btn flex items-center justify-center space-x-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                                <span>Add Playlist</span>
                            </button>
                        </div>
                        <div id="playlist-options-container" class="max-h-60 overflow-y-auto custom-scrollbar"></div>
                    </div>
                </div>
            </div>
            <div class="p-4 border-b border-[var(--border-color)]">
                <input type="text" id="search-input" placeholder="Search channels..." class="w-full p-2 custom-input text-sm">
            </div>
            <div id="playlist-container" class="flex-1 overflow-y-auto custom-scrollbar">
                <div id="playlist-element"></div>
            </div>
        </aside>

        <!-- Player Area -->
        <main class="flex-1 flex flex-col p-2 md:p-4 overflow-y-auto custom-scrollbar">
            <div id="player-container" class="relative w-full aspect-video bg-black rounded-lg flex-shrink-0">
                <video id="main-player" class="absolute top-0 left-0 w-full h-full rounded-lg" controls playsinline></video>
                <div id="youtube-player-container" class="absolute top-0 left-0 w-full h-full hidden">
                    <div id="youtube-player-div"></div>
                </div>
                <div id="error-overlay" class="hidden absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center text-center p-4 rounded-lg">
                    <p id="error-message" class="text-red-500 font-semibold">Could not load stream. The source may be offline or invalid.</p>
                </div>
            </div>

            <!-- Now Playing Info -->
            <div id="now-playing-info" class="mt-2 p-3 glass-ui rounded-lg text-center flex-shrink-0">
                <span class="text-sm text-[var(--text-muted)]">Now Playing: </span>
                <span id="now-playing-title" class="font-semibold text-white">Select a channel to begin</span>
            </div>
            
            <!-- Ad Banner Container -->
            <div id="ad-banner-container" class="my-4 w-full flex justify-center items-center">
                <!-- === LIVE AD BANNER CODE === -->
                <script async="async" data-cfasync="false" src="//pl27581368.revenuecpmgate.com/93b3aebf0ae4b257dd80dd625089ceae/invoke.js"></script>
                <div id="container-93b3aebf0ae4b257dd80dd625089ceae"></div>
            </div>
            
            <!-- Featured Channels Section -->
            <div id="featured-container" class="my-4 px-2">
                <h3 class="text-lg font-bold text-white mb-4 header-title text-center">Featured Movies and Live Tv</h3>
                <div id="featured-channels-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                    <!-- Channels will be injected here by the script -->
                </div>
            </div>
        </main>
    </div>
</div>

<!-- Add Playlist Modal -->
<div id="add-playlist-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
    <div class="glass-ui p-6 text-center rounded-lg shadow-lg shadow-purple-500/20 max-w-md w-full mx-4 space-y-4">
        <h2 class="text-xl font-bold header-title">Add Custom Playlist</h2>
        <input type="text" id="new-playlist-name" placeholder="Playlist Name" class="w-full p-2 custom-input">
        <input type="url" id="new-playlist-url" placeholder="M3U Playlist URL" class="w-full p-2 custom-input">
        <div class="flex justify-end space-x-4 pt-4">
            <button id="cancel-add-playlist-btn" class="p-2 px-4 custom-btn bg-gray-600 hover:bg-gray-500">Cancel</button>
            <button id="save-playlist-btn" class="p-2 px-4 custom-btn">Save</button>
        </div>
    </div>
</div>

<!-- About / DMCA Modal -->
<div id="dmca-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
    <div id="dmca-modal-content" class="glass-ui p-6 rounded-lg shadow-lg shadow-purple-500/20 max-w-2xl w-full space-y-4 relative">
        <h2 class="text-xl font-bold header-title text-center">Disclaimer & Policies</h2>
        <div class="max-h-[70vh] overflow-y-auto custom-scrollbar pr-4 text-sm text-slate-300 space-y-3">
            <h3 class="font-bold text-white pt-2">Data & Privacy Policy</h3>
            <p>To enhance your experience, this website uses your browser's local storage to remember your preferences. Additionally, we use Google Analytics to collect anonymous usage data to help us improve the service. We do not collect or store any personal information on our servers.</p>
            <p class="font-semibold text-white">What We Store Locally (with your consent):</p>
            <ul class="list-disc list-inside pl-4 space-y-1 text-xs">
                <li><strong>Favorites:</strong> A list of channels you have marked as favorites.</li>
                <li><strong>Custom Playlists:</strong> Any M3U playlists you have added yourself.</li>
                <li><strong>Last Played Channel/Playlist:</strong> To help you quickly resume where you left off.</li>
                <li><strong>User Consent:</strong> Your choice regarding this data policy.</li>
            </ul>
             <p>If you decline consent for local storage, these features will not be available.</p>
             <p class="font-semibold text-white pt-2">Anonymous Analytics Data:</p>
             <p>We collect aggregated and anonymized data such as popular channels, session duration, video playback progress, and general geographic location to understand how the app is used and make it better.</p>

            <h3 class="font-bold text-white pt-4">Copyright & DMCA Policy</h3>
            <p class="text-xs text-slate-400">Effective Date: 5 September 2025</p>
            <p>StreamsSphere.tv is a search index of publicly available content and does not host any files. All copyright and DMCA issues must be directed to the websites and services that are hosting the content.</p>
            <p>For more details, please review the full policy available on our main site.</p>
        </div>
        <button id="close-dmca-btn" class="absolute top-2 right-2 p-1 text-slate-400 hover:text-white">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>
</div>

<!-- Cookie Consent Banner -->
<div id="cookie-consent-banner" class="hidden fixed bottom-0 left-0 right-0 p-4 z-50">
    <div class="glass-ui max-w-4xl mx-auto rounded-lg p-4 flex flex-col md:flex-row items-center justify-between gap-4">
        <p class="text-sm text-center md:text-left">We use local storage to save your settings and anonymous analytics to improve the app. This data stays on your device or is anonymized. See our <a href="#" id="privacy-policy-link" class="text-purple-400 hover:underline">Privacy Policy</a>.</p>
        <div class="flex-shrink-0 flex gap-4">
            <button id="decline-cookies" class="p-2 px-4 text-sm custom-btn bg-gray-600 hover:bg-gray-500">Decline</button>
            <button id="accept-cookies" class="p-2 px-4 text-sm custom-btn">Accept</button>
        </div>
    </div>
</div>

<div id="mobile-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-20 hidden md:hidden"></div>

<script>
// This is the global callback function that the YouTube IFrame API will call
function onYouTubeIframeAPIReady() {
    window.dispatchEvent(new Event('youtube-api-ready'));
}

document.addEventListener('DOMContentLoaded', function() {
    // DOM Element references
    const elements = {
        mainPlayer: document.getElementById('main-player'),
        youtubePlayerContainer: document.getElementById('youtube-player-container'),
        youtubePlayerDiv: document.getElementById('youtube-player-div'),
        playerContainer: document.getElementById('player-container'),
        errorOverlay: document.getElementById('error-overlay'),
        errorMessage: document.getElementById('error-message'),
        sourceSelectorButton: document.getElementById('source-selector-button'),
        sourceSelectorIcon: document.getElementById('source-selector-icon'),
        sourceSelectorText: document.getElementById('source-selector-text'),
        sourceSelectorDropdown: document.getElementById('source-selector-dropdown'),
        playlistSearchInput: document.getElementById('playlist-search-input'),
        playlistOptionsContainer: document.getElementById('playlist-options-container'),
        searchInput: document.getElementById('search-input'),
        playlistElement: document.getElementById('playlist-element'),
        sidebar: document.getElementById('sidebar'),
        menuToggle: document.getElementById('menu-toggle'),
        mobileOverlay: document.getElementById('mobile-overlay'),
        featuredChannelsGrid: document.getElementById('featured-channels-grid'),
        addPlaylistBtn: document.getElementById('add-playlist-btn'),
        addPlaylistModal: document.getElementById('add-playlist-modal'),
        newPlaylistName: document.getElementById('new-playlist-name'),
        newPlaylistUrl: document.getElementById('new-playlist-url'),
        savePlaylistBtn: document.getElementById('save-playlist-btn'),
        cancelAddPlaylistBtn: document.getElementById('cancel-add-playlist-btn'),
        nowPlayingTitle: document.getElementById('now-playing-title'),
        aboutBtn: document.getElementById('about-btn'),
        feedbackBtn: document.getElementById('feedback-btn'),
        buyCoffeeBtn: document.getElementById('buy-coffee-btn'),
        dmcaModal: document.getElementById('dmca-modal'),
        dmcaModalContent: document.getElementById('dmca-modal-content'),
        closeDmcaBtn: document.getElementById('close-dmca-btn'),
        cookieConsentBanner: document.getElementById('cookie-consent-banner'),
        acceptCookiesBtn: document.getElementById('accept-cookies'),
        declineCookiesBtn: document.getElementById('decline-cookies'),
        privacyPolicyLink: document.getElementById('privacy-policy-link'),
    };

    // State variables
    let hls, ytPlayer, allChannelsInPlaylist = [], masterAllChannels = [];
    let favorites = [], customPlaylists = [];
    let activePlayer = null, lastClickedUrl = null, currentlyPlayingUrl = null;
    let hasConsent = false;
    let searchTimeout;
    let videoProgressTracker = {};

    // TMDB API Key and Genre Map
    const TMDB_API_KEY = '3ea9e43d0b879725ac8fda707021e858';
    const TMDB_GENRE_MAP = {28:"Action",12:"Adventure",16:"Animation",35:"Comedy",80:"Crime",99:"Documentary",18:"Drama",10751:"Family",14:"Fantasy",36:"History",27:"Horror",10402:"Music",9648:"Mystery",10749:"Romance",878:"Science Fiction",10770:"TV Movie",53:"Thriller",10752:"War",37:"Western"};

    function extractVideoID(url) {
        if (!url) return null;
        const regex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?|live)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    // Data
    const countryMap = {'af':{name:'Afghanistan',flag:'ðŸ‡¦ðŸ‡«'},'al':{name:'Albania',flag:'ðŸ‡¦ðŸ‡±'},'dz':{name:'Algeria',flag:'ðŸ‡©ðŸ‡¿'},'ad':{name:'Andorra',flag:'ðŸ‡¦ðŸ‡©'},'ao':{name:'Angola',flag:'ðŸ‡¦ðŸ‡´'},'ar':{name:'Argentina',flag:'ðŸ‡¦ðŸ‡·'},'am':{name:'Armenia',flag:'ðŸ‡¦ðŸ‡²'},'aw':{name:'Aruba',flag:'ðŸ‡¦ðŸ‡¼'},'au':{name:'Australia',flag:'ðŸ‡¦ðŸ‡º'},'at':{name:'Austria',flag:'ðŸ‡¦ðŸ‡¹'},'az':{name:'Azerbaijan',flag:'ðŸ‡¦ðŸ‡¿'},'bs':{name:'Bahamas',flag:'ðŸ‡§ðŸ‡¸'},'bh':{name:'Bahrain',flag:'ðŸ‡§ðŸ‡­'},'bd':{name:'Bangladesh',flag:'ðŸ‡§ðŸ‡©'},'bb':{name:'Barbados',flag:'ðŸ‡§ðŸ‡§'},'by':{name:'Belarus',flag:'ðŸ‡§ðŸ‡¾'},'be':{name:'Belgium',flag:'ðŸ‡§ðŸ‡ª'},'bz':{name:'Belize',flag:'ðŸ‡§ðŸ‡¿'},'bj':{name:'Benin',flag:'ðŸ‡§ðŸ‡¯'},'bm':{name:'Bermuda',flag:'ðŸ‡§ðŸ‡²'},'bt':{name:'Bhutan',flag:'ðŸ‡§ðŸ‡¹'},'bo':{name:'Bolivia',flag:'ðŸ‡§ðŸ‡´'},'ba':{name:'Bosnia and Herzegovina',flag:'ðŸ‡§ðŸ‡¦'},'bw':{name:'Botswana',flag:'ðŸ‡§ðŸ‡¼'},'br':{name:'Brazil',flag:'ðŸ‡§ðŸ‡·'},'bn':{name:'Brunei',flag:'ðŸ‡§ðŸ‡³'},'bg':{name:'Bulgaria',flag:'ðŸ‡§ðŸ‡¬'},'bf':{name:'Burkina Faso',flag:'ðŸ‡§ðŸ‡«'},'bi':{name:'Burundi',flag:'ðŸ‡§ðŸ‡®'},'kh':{name:'Cambodia',flag:'ðŸ‡°ðŸ‡­'},'cm':{name:'Cameroon',flag:'ðŸ‡¨ðŸ‡²'},'ca':{name:'Canada',flag:'ðŸ‡¨ðŸ‡¦'},'cv':{name:'Cape Verde',flag:'ðŸ‡¨ðŸ‡»'},'ky':{name:'Cayman Islands',flag:'ðŸ‡°ðŸ‡¾'},'cf':{name:'Central African Republic',flag:'ðŸ‡¨ðŸ‡«'},'td':{name:'Chad',flag:'ðŸ‡¹ðŸ‡©'},'cl':{name:'Chile',flag:'ðŸ‡¨ðŸ‡±'},'cn':{name:'China',flag:'ðŸ‡¨ðŸ‡³'},'co':{name:'Colombia',flag:'ðŸ‡¨ðŸ‡´'},'km':{name:'Comoros',flag:'ðŸ‡°ðŸ‡²'},'cg':{name:'Congo',flag:'ðŸ‡¨ðŸ‡¬'},'cd':{name:'DR Congo',flag:'ðŸ‡¨ðŸ‡©'},'cr':{name:'Costa Rica',flag:'ðŸ‡¨ðŸ‡·'},'ci':{name:'Cote d\'Ivoire',flag:'ðŸ‡¨ðŸ‡®'},'hr':{name:'Croatia',flag:'ðŸ‡­ðŸ‡·'},'cu':{name:'Cuba',flag:'ðŸ‡¨ðŸ‡º'},'cy':{name:'Cyprus',flag:'ðŸ‡¨ðŸ‡¾'},'cz':{name:'Czech Republic',flag:'ðŸ‡¨ðŸ‡¿'},'dk':{name:'Denmark',flag:'ðŸ‡©ðŸ‡°'},'dj':{name:'Djibouti',flag:'ðŸ‡©ðŸ‡¯'},'dm':{name:'Dominica',flag:'ðŸ‡©ðŸ‡²'},'do':{name:'Dominican Republic',flag:'ðŸ‡©ðŸ‡´'},'ec':{name:'Ecuador',flag:'ðŸ‡ªðŸ‡¨'},'eg':{name:'Egypt',flag:'ðŸ‡ªðŸ‡¬'},'sv':{name:'El Salvador',flag:'ðŸ‡¸ðŸ‡»'},'gq':{name:'Equatorial Guinea',flag:'ðŸ‡¬ðŸ‡¶'},'ee':{name:'Estonia',flag:'ðŸ‡ªðŸ‡ª'},'et':{name:'Ethiopia',flag:'ðŸ‡ªðŸ‡¹'},'fj':{name:'Fiji',flag:'ðŸ‡«ðŸ‡¯'},'fi':{name:'Finland',flag:'ðŸ‡«ðŸ‡®'},'fr':{name:'France',flag:'ðŸ‡«ðŸ‡·'},'ga':{name:'Gabon',flag:'ðŸ‡¬ðŸ‡¦'},'gm':{name:'Gambia',flag:'ðŸ‡¬ðŸ‡²'},'ge':{name:'Georgia',flag:'ðŸ‡¬ðŸ‡ª'},'de':{name:'Germany',flag:'ðŸ‡©ðŸ‡ª'},'gh':{name:'Ghana',flag:'ðŸ‡¬ðŸ‡­'},'gi':{name:'Gibraltar',flag:'ðŸ‡¬ðŸ‡®'},'gr':{name:'Greece',flag:'ðŸ‡¬ðŸ‡·'},'gl':{name:'Greenland',flag:'ðŸ‡¬ðŸ‡±'},'gd':{name:'Grenada',flag:'ðŸ‡¬ðŸ‡©'},'gp':{name:'Guadeloupe',flag:'ðŸ‡¬ðŸ‡µ'},'gu':{name:'Guam',flag:'ðŸ‡¬ðŸ‡º'},'gt':{name:'Guatemala',flag:'ðŸ‡¬ðŸ‡¹'},'gn':{name:'Guinea',flag:'ðŸ‡¬ðŸ‡³'},'gw':{name:'Guinea-Bissau',flag:'ðŸ‡¬ðŸ‡¼'},'gy':{name:'Guyana',flag:'ðŸ‡¬ðŸ‡¾'},'ht':{name:'Haiti',flag:'ðŸ‡­ðŸ‡¹'},'hn':{name:'Honduras',flag:'ðŸ‡­ðŸ‡³'},'hk':{name:'Hong Kong',flag:'ðŸ‡­ðŸ‡°'},'hu':{name:'Hungary',flag:'ðŸ‡­ðŸ‡º'},'is':{name:'Iceland',flag:'ðŸ‡®ðŸ‡¸'},'in':{name:'India',flag:'ðŸ‡®ðŸ‡³'},'id':{name:'Indonesia',flag:'ðŸ‡®ðŸ‡©'},'ir':{name:'Iran',flag:'ðŸ‡®ðŸ‡·'},'iq':{name:'Iraq',flag:'ðŸ‡®ðŸ‡¶'},'ie':{name:'Ireland',flag:'ðŸ‡®ðŸ‡ª'},'im':{name:'Isle of Man',flag:'ðŸ‡®ðŸ‡²'},'il':{name:'Israel',flag:'ðŸ‡®ðŸ‡±'},'it':{name:'Italy',flag:'ðŸ‡®ðŸ‡¹'},'jm':{name:'Jamaica',flag:'ðŸ‡¯ðŸ‡²'},'jp':{name:'Japan',flag:'ðŸ‡¯ðŸ‡µ'},'je':{name:'Jersey',flag:'ðŸ‡¯ðŸ‡ª'},'jo':{name:'Jordan',flag:'ðŸ‡¯ðŸ‡´'},'kz':{name:'Kazakhstan',flag:'ðŸ‡°ðŸ‡¿'},'ke':{name:'Kenya',flag:'ðŸ‡°ðŸ‡ª'},'xk':{name:'Kosovo',flag:'ðŸ‡½ðŸ‡°'},'kw':{name:'Kuwait',flag:'ðŸ‡°ðŸ‡¼'},'kg':{name:'Kyrgyzstan',flag:'ðŸ‡°ðŸ‡¬'},'la':{name:'Laos',flag:'ðŸ‡±ðŸ‡¦'},'lv':{name:'Latvia',flag:'ðŸ‡±ðŸ‡»'},'lb':{name:'Lebanon',flag:'ðŸ‡±ðŸ‡§'},'ls':{name:'Lesotho',flag:'ðŸ‡±ðŸ‡¸'},'lr':{name:'Liberia',flag:'ðŸ‡±ðŸ‡·'},'ly':{name:'Libya',flag:'ðŸ‡±ðŸ‡¾'},'li':{name:'Liechtenstein',flag:'ðŸ‡±ðŸ‡®'},'lt':{name:'Lithuania',flag:'ðŸ‡±ðŸ‡¹'},'lu':{name:'Luxembourg',flag:'ðŸ‡±ðŸ‡º'},'mo':{name:'Macau',flag:'ðŸ‡²ðŸ‡´'},'mk':{name:'North Macedonia',flag:'ðŸ‡²ðŸ‡°'},'mg':{name:'Madagascar',flag:'ðŸ‡²ðŸ‡¬'},'mw':{name:'Malawi',flag:'ðŸ‡²ðŸ‡¼'},'my':{name:'Malaysia',flag:'ðŸ‡²ðŸ‡¾'},'mv':{name:'Maldives',flag:'ðŸ‡²ðŸ‡»'},'ml':{name:'Mali',flag:'ðŸ‡²ðŸ‡±'},'mt':{name:'Malta',flag:'ðŸ‡²ðŸ‡¹'},'mq':{name:'Martinique',flag:'ðŸ‡²ðŸ‡¶'},'mr':{name:'Mauritania',flag:'ðŸ‡²ðŸ‡·'},'mu':{name:'Mauritius',flag:'ðŸ‡²ðŸ‡º'},'yt':{name:'Mayotte',flag:'ðŸ‡¾ðŸ‡¹'},'mx':{name:'Mexico',flag:'ðŸ‡²ðŸ‡½'},'md':{name:'Moldova',flag:'ðŸ‡²ðŸ‡©'},'mc':{name:'Monaco',flag:'ðŸ‡²ðŸ‡¨'},'mn':{name:'Mongolia',flag:'ðŸ‡²ðŸ‡³'},'me':{name:'Montenegro',flag:'ðŸ‡²ðŸ‡ª'},'ms':{name:'Montserrat',flag:'ðŸ‡²ðŸ‡¸'},'ma':{name:'Morocco',flag:'ðŸ‡²ðŸ‡¦'},'mz':{name:'Mozambique',flag:'ðŸ‡²ðŸ‡¿'},'mm':{name:'Myanmar',flag:'ðŸ‡²ðŸ‡²'},'na':{name:'Namibia',flag:'ðŸ‡³ðŸ‡¦'},'np':{name:'Nepal',flag:'ðŸ‡³ðŸ‡µ'},'nl':{name:'Netherlands',flag:'ðŸ‡³ðŸ‡±'},'nc':{name:'New Caledonia',flag:'ðŸ‡³ðŸ‡¨'},'nz':{name:'New Zealand',flag:'ðŸ‡³ðŸ‡¿'},'ni':{name:'Nicaragua',flag:'ðŸ‡³ðŸ‡®'},'ne':{name:'Niger',flag:'ðŸ‡³ðŸ‡ª'},'ng':{name:'Nigeria',flag:'ðŸ‡³ðŸ‡¬'},'kp':{name:'North Korea',flag:'ðŸ‡°ðŸ‡µ'},'no':{name:'Norway',flag:'ðŸ‡³ðŸ‡´'},'om':{name:'Oman',flag:'ðŸ‡´ðŸ‡²'},'pk':{name:'Pakistan',flag:'ðŸ‡µðŸ‡°'},'ps':{name:'Palestine',flag:'ðŸ‡µðŸ‡¸'},'pa':{name:'Panama',flag:'ðŸ‡µðŸ‡¦'},'pg':{name:'Papua new Guinea',flag:'ðŸ‡µðŸ‡¬'},'py':{name:'Paraguay',flag:'ðŸ‡µðŸ‡¾'},'pe':{name:'Peru',flag:'ðŸ‡µðŸ‡ª'},'ph':{name:'Philippines',flag:'ðŸ‡µðŸ‡­'},'pl':{name:'Poland',flag:'ðŸ‡µðŸ‡±'},'pt':{name:'Portugal',flag:'ðŸ‡µðŸ‡¹'},'pr':{name:'Puerto Rico',flag:'ðŸ‡µðŸ‡·'},'qa':{name:'Qatar',flag:'ðŸ‡¶ðŸ‡¦'},'re':{name:'Reunion',flag:'ðŸ‡·ðŸ‡ª'},'ro':{name:'Romania',flag:'ðŸ‡·ðŸ‡´'},'ru':{name:'Russia',flag:'ðŸ‡·ðŸ‡º'},'rw':{name:'Rwanda',flag:'ðŸ‡·ðŸ‡¼'},'kn':{name:'Saint Kitts and Nevis',flag:'ðŸ‡°ðŸ‡³'},'lc':{name:'Saint Lucia',flag:'ðŸ‡±ðŸ‡¨'},'vc':{name:'Saint Vincent and the Grenadines',flag:'ðŸ‡»ðŸ‡¨'},'sm':{name:'San Marino',flag:'ðŸ‡¸ðŸ‡²'},'st':{name:'Sao Tome and Principe',flag:'ðŸ‡¸ðŸ‡¹'},'sa':{name:'Saudi Arabia',flag:'ðŸ‡¸ðŸ‡¦'},'sn':{name:'Senegal',flag:'ðŸ‡¸ðŸ‡³'},'rs':{name:'Serbia',flag:'ðŸ‡·ðŸ‡¸'},'sc':{name:'Seychelles',flag:'ðŸ‡¸ðŸ‡¨'},'sl':{name:'Sierra Leone',flag:'ðŸ‡¸ðŸ‡±'},'sg':{name:'Singapore',flag:'ðŸ‡¸ðŸ‡¬'},'sk':{name:'Slovakia',flag:'ðŸ‡¸ðŸ‡°'},'si':{name:'Slovenia',flag:'ðŸ‡¸ðŸ‡®'},'so':{name:'Somalia',flag:'ðŸ‡¸ðŸ‡´'},'za':{name:'South Africa',flag:'ðŸ‡¿ðŸ‡¦'},'kr':{name:'South Korea',flag:'ðŸ‡°ðŸ‡·'},'ss':{name:'South Sudan',flag:'ðŸ‡¸ðŸ‡¸'},'es':{name:'Spain',flag:'ðŸ‡ªðŸ‡¸'},'lk':{name:'Sri Lanka',flag:'ðŸ‡±ðŸ‡°'},'sd':{name:'Sudan',flag:'ðŸ‡¸ðŸ‡©'},'sr':{name:'Suriname',flag:'ðŸ‡¸ðŸ‡·'},'se':{name:'Sweden',flag:'ðŸ‡¸ðŸ‡ª'},'ch':{name:'Switzerland',flag:'ðŸ‡¨ðŸ‡­'},'sy':{name:'Syria',flag:'ðŸ‡¸ðŸ‡¾'},'tw':{name:'Taiwan',flag:'ðŸ‡¹ðŸ‡¼'},'tz':{name:'Tanzania',flag:'ðŸ‡¹ðŸ‡¿'},'th':{name:'Thailand',flag:'ðŸ‡¹ðŸ‡­'},'tl':{name:'Timor-Leste',flag:'ðŸ‡¹ðŸ‡±'},'tg':{name:'Togo',flag:'ðŸ‡¹ðŸ‡¬'},'to':{name:'Tonga',flag:'ðŸ‡¹ðŸ‡´'},'tt':{name:'Trinidad and Tobago',flag:'ðŸ‡¹ðŸ‡¹'},'tn':{name:'Tunisia',flag:'ðŸ‡¹ðŸ‡³'},'tr':{name:'Turkey',flag:'ðŸ‡¹ðŸ‡·'},'tm':{name:'Turkmenistan',flag:'ðŸ‡¹ðŸ‡²'},'ug':{name:'Uganda',flag:'ðŸ‡ºðŸ‡¬'},'ua':{name:'Ukraine',flag:'ðŸ‡ºðŸ‡¦'},'ae':{name:'United Arab Emirates',flag:'ðŸ‡¦ðŸ‡ª'},'gb':{name:'United Kingdom',flag:'ðŸ‡¬ðŸ‡§'},'us':{name:'United States',flag:'ðŸ‡ºðŸ‡¸'},'uy':{name:'Uruguay',flag:'ðŸ‡ºðŸ‡¾'},'uz':{name:'Uzbekistan',flag:'ðŸ‡ºðŸ‡¿'},'ve':{name:'Venezuela',flag:'ðŸ‡»ðŸ‡ª'},'vn':{name:'Vietnam',flag:'ðŸ‡»ðŸ‡³'},'ye':{name:'Yemen',flag:'ðŸ‡¾ðŸ‡ª'},'zm':{name:'Zambia',flag:'ðŸ‡¿ðŸ‡²'},'zw':{name:'Zimbabwe',flag:'ðŸ‡¿ðŸ‡¼'}};
    const countryCodes = Object.keys(countryMap);
    const countryPlaylists = countryCodes.map(code => {
        const country = countryMap[code];
        const url = (code === 'gb') 
            ? 'https://raw.githubusercontent.com/devsground/IPTV/master/country/T-Z/united_kingdom.m3u'
            : `https://iptv-org.github.io/iptv/countries/${code}.m3u`;
        return { name: country.name, url: url, icon: `<span class="text-xl">${country.flag}</span>` };
    });

    let BASE_PLAYLISTS = [
        { name: 'YT Live', icon: 'ðŸ”´', channels: [
            { title: 'The Osbournes Podcast', url: 'https://www.youtube.com/live/mozvQNIsvik', logo: "", sourcePlaylistName: 'YT Live'},
            { title: 'lofi hip hop radio - beats to relax/study to', url: 'https://www.youtube.com/watch?v=jfKfPfyJRdk', logo: "", sourcePlaylistName: 'YT Live'},
        ]},
        { name: 'YT Series', icon: 'ðŸ“º', categorized: true, channels: [
        ].map(video => ({ ...video, logo: `https://i.ytimg.com/vi/${extractVideoID(video.url)}/hqdefault.jpg`, sourcePlaylistName: 'YT Series' })) },
        { name: 'Fire TV', url: 'https://www.apsattv.com/firetv.m3u', icon: 'ðŸ”¥'},
        { name: 'Freetv', url: 'https://www.apsattv.com/freetv.m3u', icon: 'ðŸ“º'},
        { name: 'Freemoviesplus', url: 'https://www.apsattv.com/freemoviesplus.m3u', icon: 'ðŸ¿'},
        { name: 'Klowd TV', url: 'https://www.apsattv.com/klowd.m3u', icon: 'â˜ï¸'},
        { name: 'LG', url: 'https://www.apsattv.com/lg.m3u', icon: 'ðŸ“º'},
        { name: 'Plex US', url: 'https://raw.githubusercontent.com/iptv-org/iptv/master/streams/us_plex.m3u', icon: 'â–¶ï¸'},
        { 
            name: 'Internet Archive ðŸ“ºðŸŽ¬', 
            icon: 'ðŸ›ï¸', 
            isNested: true,
            structure: {
                'Movies': {
                    // Movie genres will be populated dynamically here
                },
                'Series': {}
            }
        },
        { name: 'Weelly', url: 'https://www.apsattv.com/weelly.m3u', icon: 'ðŸ“º'},
        { name: 'Vidaa', url: 'https://www.apsattv.com/vidaa.m3u', icon: 'ðŸ“º'},
        { name: 'Xiaomi', url: 'https://www.apsattv.com/xiaomi.m3u', icon: 'ðŸ“±'},
        { name: 'Xumo', url: 'https://www.apsattv.com/xumo.m3u', icon: 'ðŸ“º'},
        { name: 'Zeasn', url: 'https://www.apsattv.com/zeasn.m3u', icon: 'ðŸ“º'},
        ...countryPlaylists
    ].sort((a, b) => a.name.localeCompare(b.name));

    let allPlaylists = [];

    const CORS_PROXIES = [
        '', // Direct fetch first
        'https://corsproxy.io/?', 
        'https://api.allorigins.win/raw?url=',
        'https://proxy.cors.sh/'
    ];
    // Cache is set to 2 hours to balance performance with the dynamic nature of M3U playlists.
    const CACHE_EXPIRATION_MS = 2 * 60 * 60 * 1000;

    // --- Player Logic ---
    function initializeYouTubePlayer() {
        if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
            window.addEventListener('youtube-api-ready', createPlayer, { once: true });
        } else {
            createPlayer();
        }
    }

    function createPlayer() {
        if (ytPlayer) return;
        ytPlayer = new YT.Player(elements.youtubePlayerDiv, {
            height: '100%',
            width: '100%',
            playerVars: {
                'playsinline': 1,
                'autoplay': 1,
                'rel': 0,
                'modestbranding': 1
            },
            events: {
                'onReady': () => hideErrorOverlay(),
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            hideErrorOverlay();
        }
        if (event.data === YT.PlayerState.ENDED) {
            const currentPlaylistName = elements.sourceSelectorText.textContent.trim();
            const playlist = allPlaylists.find(p => p.name === currentPlaylistName);
            if(playlist) playNextEpisode(currentlyPlayingUrl, playlist.name);
        }
    }

    function playNextEpisode(currentUrl, playlistName) {
        if (!currentUrl) return;

        const playlist = allPlaylists.find(p => p.name === playlistName);
        if (!playlist || (!playlist.categorized && !playlist.isNested)) return;
        
        const currentChannel = allChannelsInPlaylist.find(c => c.url === currentUrl);
        if (!currentChannel || !currentChannel.group) return;

        let seriesChannels = allChannelsInPlaylist.filter(c => c.group === currentChannel.group);
        
        seriesChannels.sort((a, b) => {
            const numA = a.title.match(/\d+/g);
            const numB = b.title.match(/\d+/g);
            if (numA && numB) {
                const lastNumA = parseInt(numA[numA.length-1]);
                const lastNumB = parseInt(numB[numB.length-1]);
                if(lastNumA !== lastNumB) return lastNumA - lastNumB;
            }
            return a.title.localeCompare(b.title);
        });

        const currentIndex = seriesChannels.findIndex(c => c.url === currentUrl);

        if (currentIndex > -1 && currentIndex < seriesChannels.length - 1) {
            const nextChannel = seriesChannels[currentIndex + 1];
            loadStream(nextChannel.url);
            const nextChannelElement = document.querySelector(`.channel-item[data-url="${CSS.escape(nextChannel.url)}"]`);
            if (nextChannelElement) {
                document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                nextChannelElement.classList.add('active');
            }
        }
    }
    
    function initializePlayers() {
        elements.mainPlayer.addEventListener('error', (e) => {
            if (activePlayer === 'native' || activePlayer === 'hls') {
                 console.error('Native/HLS Video Element Error:', elements.mainPlayer.error);
                 showErrorOverlay("Stream failed to load.");
            }
        });

        initializeYouTubePlayer();
    }

    function showErrorOverlay(message = 'Could not load stream. The source may be offline or invalid.') { 
        elements.errorMessage.textContent = message;
        elements.errorOverlay.classList.remove('hidden');
        if (typeof gtag === 'function') {
            gtag('event', 'playback_error', {
                'error_message': message,
                'stream_url': currentlyPlayingUrl
            });
        }
    }
    function hideErrorOverlay() { 
        elements.errorOverlay.classList.add('hidden'); 
    }

    async function fetchWithFallback(url) {
        for (const proxy of CORS_PROXIES) {
            try {
                const fetchUrl = proxy ? proxy + url : url;
                const response = await fetch(fetchUrl);
                if (response.ok) return await response.text();
            } catch (e) {
                console.warn(`Fetch failed for ${url} with proxy '${proxy}':`, e);
            }
        }
        throw new Error(`All CORS proxies failed for ${url}.`);
    }

    async function parseM3U(data, playlistName) {
        const lines = data.split('\n');
        const channels = [];
        const groups = {};
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].startsWith('#EXTINF:')) {
                const info = lines[i];
                let url = lines[i + 1]?.trim();
                if (url && (url.startsWith('http') || url.startsWith('//'))) {
                    if (url.includes('archive.org/embed/')) url = url.replace('/embed/', '/download/');
                    if (url.includes('archive.org')) url = url.replace('http://', 'https://');
                    
                    const title = info.match(/,(.+)/)?.[1]?.trim() || 'Unknown';
                    const logo = info.match(/tvg-logo="([^"]+)"/)?.[1];
                    const group = info.match(/group-title="([^"]+)"/)?.[1]?.trim() || 'Uncategorized';
                    
                    const channelData = { title, logo, url, group, sourcePlaylistName: playlistName };
                    channels.push(channelData);
                    if (!groups[group]) groups[group] = [];
                    groups[group].push(channelData);
                }
            }
        }
        return { channels, groups };
    }

    async function loadDataForSource(sourceKey) {
        elements.playlistElement.innerHTML = `<div class="flex justify-center items-center h-full"><div class="loader"></div></div>`;
        
        const playlist = allPlaylists.find(p => p.name === sourceKey);
        if (!playlist) {
            elements.playlistElement.innerHTML = `<p class="p-4 text-center text-[var(--text-muted)]">Playlist not found.</p>`;
            return;
        }

        if (playlist.isNested) {
            displayInternetArchiveCategories([], playlist.structure);
            return;
        }

        allChannelsInPlaylist = [];
        let groupedChannels = {};

        if (sourceKey === 'Favorites') {
            if (favorites.length === 0) {
                elements.playlistElement.innerHTML = `<p class="p-4 text-center text-[var(--text-muted)]">No favorites yet. Accept data policy to use this feature.</p>`;
                return;
            }
            allChannelsInPlaylist = favorites;
            populatePlaylistUI(favorites, false);
            return;
        }

        if (playlist.channels) {
            allChannelsInPlaylist = playlist.channels;
            if (playlist.channels.length === 0) {
                elements.playlistElement.innerHTML = `<p class="p-4 text-center text-[var(--text-muted)]">This playlist is currently empty.</p>`;
                return;
            }
            groupedChannels = {};
            playlist.channels.forEach(channel => {
                const group = channel.group || playlist.name;
                if (!groupedChannels[group]) groupedChannels[group] = [];
                groupedChannels[group].push(channel);
            });
            await displayCategories(groupedChannels);
            return;
        }

        const cacheKey = `iptv_cache_${playlist.name}`;
        try {
            if(hasConsent) {
                const cachedItem = localStorage.getItem(cacheKey);
                if (cachedItem) {
                    const { timestamp, data } = JSON.parse(cachedItem);
                    if ((Date.now() - timestamp) < CACHE_EXPIRATION_MS) {
                        const parsed = await parseM3U(data, playlist.name);
                        allChannelsInPlaylist = parsed.channels;
                        groupedChannels = parsed.groups;
                        await displayCategories(groupedChannels);
                        return;
                    }
                }
            }
            const data = await fetchWithFallback(playlist.url);
            if(hasConsent) {
                localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: data }));
            }
            const parsed = await parseM3U(data, playlist.name);
            allChannelsInPlaylist = parsed.channels;
            groupedChannels = parsed.groups;
            await displayCategories(groupedChannels);
        } catch (error) {
            console.error(`Failed to load playlist ${playlist.name}`, error);
            elements.playlistElement.innerHTML = `<p class="p-4 text-center text-red-500">Could not load ${playlist.name}.</p>`;
        }
    }

    const categoryIcons = {
        'Business': 'ðŸ’¼', 'Comedy': 'ðŸ˜‚', 'Culture': 'ðŸŽ­', 'Documentary': 'ðŸŽ¥',
        'Family': 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦', 'General': 'ðŸŒ', 'Kids': 'ðŸ‘¶', 'Lifestyle': 'ðŸ’…',
        'Music': 'ðŸŽµ', 'News': 'ðŸ“°', 'Religious': 'â›ª', 'Sports': 'âš½',
        'Classic': 'ðŸ›ï¸', 'Horror': 'ðŸ‘»', 'Science Fiction': 'ðŸ‘½', 'Animation': 'âœï¸',
        'War': 'âš”ï¸', 'Action': 'ðŸ’¥', 'Drama': 'ðŸŽ­', 'Mystery': 'â“', 'Western': 'ðŸ¤ ',
        'All': 'ðŸ“š', 'Default': 'ðŸ“', 'Movies': 'ðŸŽ¬', 'Series': 'ðŸ“º', 'All Movies': 'ðŸŽ¬'
    };

    function displayInternetArchiveCategories(path = [], structure) {
        elements.playlistElement.innerHTML = '';
        let currentLevel = structure;
        path.forEach(key => {
            currentLevel = currentLevel[key];
        });

        if (path.length > 0) {
            const backButton = document.createElement('button');
            backButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg> Back`;
            backButton.className = 'back-button w-full flex items-center space-x-2 p-3 text-left text-purple-400 hover:bg-purple-500/20 border-b border-[var(--border-color)]';
            backButton.addEventListener('click', () => {
                const newPath = path.slice(0, -1);
                displayInternetArchiveCategories(newPath, structure);
            });
            elements.playlistElement.appendChild(backButton);
        }

        const sortedKeys = Object.keys(currentLevel).sort((a, b) => {
            if (a === 'All Movies') return -1;
            if (b === 'All Movies') return 1;
            if (a === 'Uncategorized') return 1; // Push Uncategorized to the end
            if (b === 'Uncategorized') return -1;
            return a.localeCompare(b);
        });

        for (const key of sortedKeys) {
            const nextLevel = currentLevel[key];
            const isChannelList = Array.isArray(nextLevel);

            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item flex items-center space-x-3 p-3 cursor-pointer hover:bg-purple-500/20 transition-colors duration-200 border-b border-[var(--border-color)]';
            
            let iconHTML = categoryIcons[key] || categoryIcons['Default'];
            
            if (isChannelList && nextLevel.length > 0 && nextLevel[0].logo) {
                 iconHTML = `<img src="${nextLevel[0].logo}" class="w-10 h-10 rounded-md object-cover">`;
            } else if (!isChannelList) { // It's an object of categories
                // Try to find a logo from the first real channel list inside
                const firstSubKey = Object.keys(nextLevel)[0];
                if(firstSubKey && Array.isArray(nextLevel[firstSubKey]) && nextLevel[firstSubKey][0]?.logo) {
                    iconHTML = `<img src="${nextLevel[firstSubKey][0].logo}" class="w-10 h-10 rounded-md object-cover">`;
                }
            }


            if (isChannelList) {
                categoryDiv.innerHTML = `<div class="flex-shrink-0 w-10 h-10 flex items-center justify-center text-xl">${iconHTML}</div> <span class="flex-1">${key} (${nextLevel.length})</span>`;
                categoryDiv.addEventListener('click', () => {
                    allChannelsInPlaylist = nextLevel;
                    populatePlaylistUI(nextLevel, true, () => displayInternetArchiveCategories(path, structure));
                });
            } else {
                const subItemCount = Object.keys(nextLevel).length;
                categoryDiv.innerHTML = `<div class="flex-shrink-0 w-10 h-10 flex items-center justify-center text-xl">${iconHTML}</div> <span class="flex-1">${key} (${subItemCount})</span>`;
                categoryDiv.addEventListener('click', () => {
                    displayInternetArchiveCategories([...path, key], structure);
                });
            }
            elements.playlistElement.appendChild(categoryDiv);
        }
    }

    async function displayCategories(groupedChannels) {
        elements.playlistElement.innerHTML = ``;
        if (allChannelsInPlaylist.length > 0 && Object.keys(groupedChannels).length > 1) {
            const allChannelsDiv = document.createElement('div');
            allChannelsDiv.className = 'category-item flex items-center space-x-3 p-3 cursor-pointer hover:bg-purple-500/20 transition-colors duration-200 border-b border-[var(--border-color)]';
            allChannelsDiv.innerHTML = `<div class="flex-shrink-0 w-6 h-6 flex items-center justify-center text-xl">${categoryIcons['All']}</div> <span>All Channels (${allChannelsInPlaylist.length})</span>`;
            allChannelsDiv.addEventListener('click', () => populatePlaylistUI(allChannelsInPlaylist, true, () => displayCategories(groupedChannels)));
            elements.playlistElement.appendChild(allChannelsDiv);
        }

        const sortedCategories = Object.entries(groupedChannels).sort(([a], [b]) => a.localeCompare(b));

        if (sortedCategories.length === 1) {
            populatePlaylistUI(sortedCategories[0][1], false);
            return;
        }

        for (const [category, channels] of sortedCategories) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item flex items-center space-x-3 p-3 cursor-pointer hover:bg-purple-500/20 transition-colors duration-200 border-b border-[var(--border-color)]';
            const sortedIconKeys = Object.keys(categoryIcons).sort((a, b) => b.length - a.length);
            const iconKey = Object.keys(categoryIcons).find(key => key === category) || sortedIconKeys.find(key => category.toLowerCase().includes(key.toLowerCase())) || 'Default';
            const iconHTML = categoryIcons[iconKey];
            categoryDiv.innerHTML = `<div class="flex-shrink-0 w-6 h-6 flex items-center justify-center text-xl">${iconHTML}</div> <span>${category} (${channels.length})</span>`;
            categoryDiv.addEventListener('click', () => {
                populatePlaylistUI(channels, true, () => displayCategories(groupedChannels));
            });
            elements.playlistElement.appendChild(categoryDiv);
        }
    }
    
    async function populatePlaylistUI(channels, showBackButton = false, backFunction = null) {
        elements.playlistElement.innerHTML = '';
        if (showBackButton) {
            const backButton = document.createElement('button');
            backButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg> Back`;
            backButton.className = 'back-button w-full flex items-center space-x-2 p-3 text-left text-purple-400 hover:bg-purple-500/20 border-b border-[var(--border-color)]';
            backButton.addEventListener('click', backFunction || (() => loadDataForSource(elements.sourceSelectorText.textContent.trim())));
            elements.playlistElement.appendChild(backButton);
        }
        const listContainer = document.createElement('div');
        listContainer.className = 'flex flex-col p-1';
        elements.playlistElement.appendChild(listContainer);
        
        channels.sort((a, b) => {
            const numA = a.title.match(/\d+/g);
            const numB = b.title.match(/\d+/g);
            if (numA && numB && numA.length > 1 && numB.length > 1) {
                if (parseInt(numA[0]) !== parseInt(numB[0])) return parseInt(numA[0]) - parseInt(numB[0]);
                if (parseInt(numA[1]) !== parseInt(numB[1])) return parseInt(numA[1]) - parseInt(numB[1]);
            }
            return a.title.localeCompare(b.title);
        });

        for (const channel of channels) {
            const channelDiv = document.createElement('div');
            channelDiv.className = 'channel-item flex items-center space-x-3 p-2 cursor-pointer rounded-lg transition-all duration-200';
            channelDiv.dataset.url = channel.url;
            const isFavorite = favorites.some(f => f.url === channel.url);
            channelDiv.innerHTML = `
                <div class="flex-shrink-0 w-12 h-12 bg-black/20 rounded-md flex items-center justify-center overflow-hidden">
                    <img src="${channel.logo || ''}" class="channel-logo w-full h-full object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                    <div class="channel-logo-fallback w-full h-full flex items-center justify-center text-xl font-bold text-slate-500" style="display: flex;">${(channel.title || 'L').charAt(0)}</div>
                </div>
                <span class="channel-title flex-1 text-sm text-slate-300">${channel.title || 'Loading...'}</span>
                <button class="favorite-btn p-1 text-lg text-slate-600 hover:text-purple-400 transition-colors ${isFavorite ? 'favorite' : ''}" data-channel='${JSON.stringify(channel)}'>â˜…</button>
            `;
            listContainer.appendChild(channelDiv);
        }
    }

    async function populateFeaturedChannels() {
        const featuredGrid = elements.featuredChannelsGrid;
        if (!featuredGrid) return;
        // Display loader immediately
        featuredGrid.innerHTML = `<div class="col-span-full flex justify-center items-center h-full"><div class="loader"></div></div>`;

        if (masterAllChannels.length === 0) {
            await fetchAllChannelsForFeatured();
        }

        const totalFeatured = 12;

        const liveTvPool = masterAllChannels.filter(c => 
            c.sourcePlaylistName &&
            !c.sourcePlaylistName.includes('Archive') && 
            !c.sourcePlaylistName.includes('YT') &&
            !c.sourcePlaylistName.includes('freemoviesplus') &&
            c.url && !c.url.includes('archive.org')
        ).sort(() => 0.5 - Math.random());

        const moviePool = masterAllChannels.filter(c => 
            c.sourcePlaylistName &&
            (c.sourcePlaylistName.includes('freemoviesplus') ||
            (c.sourcePlaylistName.includes('Archive') && c.group && c.title && !c.title.match(/S\d{1,2}E\d{1,2}/i)))
        ).sort(() => 0.5 - Math.random());

        const seriesPool = masterAllChannels.filter(c => 
             c.sourcePlaylistName && c.title &&
             (c.sourcePlaylistName.includes('YT Series') ||
             (c.sourcePlaylistName.includes('Archive') && c.title.match(/S\d{1,2}E\d{1,2}/i)))
        ).sort(() => 0.5 - Math.random());
        
        const selectedLive = liveTvPool.slice(0, Math.ceil(totalFeatured * 0.5));
        const selectedMovies = moviePool.slice(0, Math.ceil(totalFeatured * 0.25));
        const selectedSeries = seriesPool.slice(0, Math.ceil(totalFeatured * 0.25));
        
        const selectedChannels = [...selectedLive, ...selectedMovies, ...selectedSeries].sort(() => 0.5 - Math.random()).slice(0, totalFeatured);
        
        // Clear loader and prepare for content
        featuredGrid.innerHTML = '';
        if (selectedChannels.length === 0) {
            featuredGrid.innerHTML = `<p class="col-span-full text-center text-[var(--text-muted)]">Could not load featured channels. Try another playlist.</p>`;
            return;
        }

        for (const channel of selectedChannels) {
            const caseDiv = document.createElement('div');
            caseDiv.className = 'dvd-case';
            caseDiv.dataset.channel = JSON.stringify(channel);
            
            let logoUrl = channel.logo || '';
            
            if (!logoUrl) {
                if (channel.group && (channel.sourcePlaylistName.includes('YT Series') || channel.sourcePlaylistName.includes('Archive'))) {
                    const details = await fetchTvShowDetailsFromTMDB(channel.group);
                    logoUrl = details ? details.logo : '';
                } else if (channel.title) {
                    const details = await fetchMovieDetailsFromTMDB(channel.title);
                    logoUrl = details ? details.logo : '';
                }
            }

            caseDiv.innerHTML = `
                <div class="dvd-case-img-container">
                    <img src="${logoUrl || ''}" class="dvd-case-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                    <div class="channel-logo-fallback w-full h-full flex items-center justify-center text-2xl font-bold text-slate-500" style="${logoUrl ? 'display:none;' : ''}">${(channel.title || 'L').charAt(0)}</div>
                </div>
                <div class="dvd-case-title">${channel.title || 'Unknown'}</div>
            `;
            
            caseDiv.addEventListener('click', () => {
                const clickedChannel = JSON.parse(caseDiv.dataset.channel);
                loadStream(clickedChannel.url);
                goToChannel(clickedChannel);
            });
            featuredGrid.appendChild(caseDiv);
        }
    }

    async function goToChannel(channel) {
        document.querySelector('main').scrollTo({ top: 0, behavior: 'smooth' });
        
        const sourcePlaylist = allPlaylists.find(p => p.name === channel.sourcePlaylistName);
        if (!sourcePlaylist) return;

        updateSourceSelectorButton(sourcePlaylist);
        await loadDataForSource(sourcePlaylist.name);
        
        setTimeout(() => {
            document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
            const targetChannelElement = document.querySelector(`.channel-item[data-url="${CSS.escape(channel.url)}"]`);
            if (targetChannelElement) {
                targetChannelElement.classList.add('active');
                targetChannelElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 500);
    }

    function loadStream(url) {
        playStream(url);
    }

    function playStream(url) {
        const startTime = performance.now();
        hideErrorOverlay();
        currentlyPlayingUrl = url;
        videoProgressTracker = { '25': false, '50': false, '75': false, '90': false };
        const videoId = extractVideoID(url);

        const allKnownChannels = [...masterAllChannels, ...favorites];
        const currentChannel = allKnownChannels.find(c => c.url === url);
        elements.nowPlayingTitle.textContent = currentChannel ? currentChannel.title : 'Loading...';

        // --- ANALYTICS EVENT ---
        if (typeof gtag === 'function' && currentChannel) {
            gtag('event', 'play_stream', {
                'channel_title': currentChannel.title,
                'playlist_name': currentChannel.sourcePlaylistName
            });
        }
        
        const handlePlaying = () => {
            const loadTime = (performance.now() - startTime) / 1000;
             if (typeof gtag === 'function') {
                gtag('event', 'stream_load_time', {
                    'value': loadTime.toFixed(2),
                    'channel_title': currentChannel?.title || 'Unknown'
                });
            }
            elements.mainPlayer.removeEventListener('playing', handlePlaying);
        };
        elements.mainPlayer.addEventListener('playing', handlePlaying);


        if (ytPlayer && typeof ytPlayer.stopVideo === 'function') ytPlayer.stopVideo();
        elements.mainPlayer.pause();
        elements.mainPlayer.removeAttribute('src');
        if (hls) {
            hls.destroy();
            hls = null;
        }

        if (videoId) {
            activePlayer = 'youtube';
            elements.mainPlayer.classList.add('hidden');
            elements.youtubePlayerContainer.classList.remove('hidden');
            if (ytPlayer && typeof ytPlayer.loadVideoById === 'function') {
                ytPlayer.loadVideoById(videoId);
            } else {
                initializeYouTubePlayer();
            }
        } else {
            elements.youtubePlayerContainer.classList.add('hidden');
            elements.mainPlayer.classList.remove('hidden');
            
            if (url.endsWith('.m3u8') && Hls.isSupported()) {
                activePlayer = 'hls';
                hls = new Hls({ fragLoadingMaxRetry: 4, manifestLoadingMaxRetry: 1, manifestLoadingTimeOut: 20000 });
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        console.error('HLS Error:', data);
                        showErrorOverlay("HLS stream failed.");
                    }
                });
                hls.attachMedia(elements.mainPlayer);
                hls.loadSource(url);
                hls.once(Hls.Events.MANIFEST_PARSED, () => elements.mainPlayer.play().catch(e => {
                    console.error("HLS Playback error:", e);
                    showErrorOverlay("Could not play HLS stream.");
                }));
            } else { 
                activePlayer = 'native';
                elements.mainPlayer.src = url;
                elements.mainPlayer.play().catch(e => {
                    console.error("Native playback error:", e);
                    showErrorOverlay("Native video playback failed.");
                });
            }
        }
        if(hasConsent) localStorage.setItem('iptv_last_played', url);
    }


    function toggleFavorite(button) {
        if (!hasConsent) {
            alert("Please accept the data policy to use favorites.");
            return;
        };
        const channelData = JSON.parse(button.dataset.channel);
        const index = favorites.findIndex(f => f.url === channelData.url);
        let action = 'add';
        if (index !== -1) {
            favorites.splice(index, 1);
            button.classList.remove('favorite');
            action = 'remove';
        } else {
            favorites.push(channelData);
            button.classList.add('favorite');
        }

        if (typeof gtag === 'function') {
            gtag('event', 'toggle_favorite', {
                'action': action,
                'channel_title': channelData.title
            });
            gtag('set', 'user_properties', {
                'is_favorite_user': favorites.length > 5
            });
        }
        localStorage.setItem('iptv_favorites', JSON.stringify(favorites));
        if (elements.sourceSelectorText.textContent.trim().includes('Favorites')) {
            loadDataForSource('Favorites');
        }
    }
    
    function enterFullscreen() {
        if (activePlayer === 'hls' || activePlayer === 'native') {
           const playerElement = elements.mainPlayer;
            if (playerElement.requestFullscreen) playerElement.requestFullscreen();
            else if (playerElement.mozRequestFullScreen) playerElement.mozRequestFullScreen();
            else if (playerElement.webkitRequestFullscreen) playerElement.webkitRequestFullscreen();
            else if (playerElement.msRequestFullscreen) playerElement.msRequestFullscreen();
        }
    }

    function updateSourceSelectorButton(playlist) {
        elements.sourceSelectorIcon.innerHTML = `<span class="text-xl">${playlist.icon || 'â˜…'}</span>`;
        elements.sourceSelectorText.textContent = playlist.name;
    };

    function setupAllPlaylists() {
        const favoritesPlaylist = { name: 'Favorites', icon: 'â­'};
        if(hasConsent) {
            customPlaylists = JSON.parse(localStorage.getItem('iptv_custom_playlists')) || [];
        } else {
            customPlaylists = [];
        }
        allPlaylists = [favoritesPlaylist, ...customPlaylists, ...BASE_PLAYLISTS].sort((a,b) => {
            if (a.name === 'Favorites') return -1;
            if (b.name === 'Favorites') return 1;
            return a.name.localeCompare(b.name);
        });
    }

    function renderPlaylistOptions(playlistsToRender) {
        elements.playlistOptionsContainer.innerHTML = '';
        playlistsToRender.forEach(playlist => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'flex items-center justify-between space-x-2 p-2 hover:bg-purple-500/20';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'flex items-center space-x-2 truncate flex-1 cursor-pointer';
            contentDiv.innerHTML = `<span class="flex-shrink-0 w-6 text-center text-xl">${playlist.icon || 'ðŸ“'}</span> <span class="truncate">${playlist.name}</span>`;
            contentDiv.addEventListener('click', () => {
                if (hasConsent) localStorage.setItem('iptv_last_source', playlist.name);
                if (typeof gtag === 'function') {
                    gtag('event', 'select_playlist', {
                        'playlist_name': playlist.name
                    });
                }
                updateSourceSelectorButton(playlist);
                loadDataForSource(playlist.name);
                elements.sourceSelectorDropdown.classList.add('hidden');
            });
            optionDiv.appendChild(contentDiv);

            if(playlist.isCustom) {
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&#x2715;'; // 'X' symbol
                deleteBtn.className = 'p-1 text-slate-400 hover:text-white flex-shrink-0';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if(!hasConsent) return;
                    customPlaylists = customPlaylists.filter(p => p.url !== playlist.url);
                    localStorage.setItem('iptv_custom_playlists', JSON.stringify(customPlaylists));
                    setupAllPlaylists();
                    renderPlaylistOptions(allPlaylists);
                });
                optionDiv.appendChild(deleteBtn);
            }
            elements.playlistOptionsContainer.appendChild(optionDiv);
        });
    }

    async function fetchAllChannelsForFeatured() {
        if (masterAllChannels.length > 0) return;
        
        const playlistsToFetch = [...customPlaylists, ...BASE_PLAYLISTS];
        
        const promises = playlistsToFetch.map(async (playlist) => {
            if (playlist.isNested) {
                function flatten(structure, name) {
                    let channels = [];
                    for (const key in structure) {
                        const category = structure[key];
                        if (Array.isArray(category)) {
                            channels.push(...category.map(c => ({...c, sourcePlaylistName: name})));
                        } else if (typeof category === 'object') {
                            channels.push(...flatten(category, name));
                        }
                    }
                    return channels;
                }
                return flatten(playlist.structure, playlist.name);
            }
            if (playlist.channels) {
                return playlist.channels.map(c => ({...c, sourcePlaylistName: playlist.name}));
            }
            try {
                const data = await fetchWithFallback(playlist.url);
                const { channels } = await parseM3U(data, playlist.name);
                return channels;
            } catch(e) {
                console.warn(`Could not fetch ${playlist.name} for featured list.`);
                return [];
            }
        });

        const results = await Promise.allSettled(promises);
        
        masterAllChannels = results
            .filter(result => result.status === 'fulfilled')
            .flatMap(result => result.value);
    }
    
    function cleanTitleForSearch(title) {
        let cleaned = title;
        // Remove file extensions
        cleaned = cleaned.replace(/\.(mp4|mkv|avi|mov|wmv)$/i, '');
        // Remove year in parentheses or brackets, e.g., (1999) or [2023]
        cleaned = cleaned.replace(/\s*[\[\(]\d{4}[\]\)]/, '');
        // Replace common separators with spaces
        cleaned = cleaned.replace(/[._]/g, ' ');
        // Remove a wide range of release tags and junk
        cleaned = cleaned.replace(/(1080p|720p|480p|2160p|4K|UHD|BluRay|WEB-DL|WEBRip|HDTV|x264|x265|h264|h265|AAC|DTS|HDRip|EXTENDED|REMASTERED|DIRECTORS CUT|UNCUT|DUAL AUDIO|MULTI-LANG|SUBBED|DUBBED|[-~]\s*\w+$)/gi, '');
        // Remove season/episode identifiers
        cleaned = cleaned.replace(/S\d{1,2}E\d{1,2}/i, '');
        // Remove year that might just be floating
        cleaned = cleaned.replace(/\s+\d{4}\s+/, ' ');
        // Trim whitespace from start and end
        return cleaned.trim();
    }

    function cleanEpisodeTitle(rawTitle, seriesName) {
        let cleaned = rawTitle.replace(/[/_]/g, ' '); // Replace slashes and underscores first
        
        // Use a flexible regex to find season/episode patterns
        const sePattern = /(S(\d{1,2}))?[\s.E|x](\d{1,3})|Season (\d{1,2}) Episode (\d{1,3})/i;
        const match = cleaned.match(sePattern);
        
        if (match) {
            const season = (match[2] || match[4] || '').padStart(2, '0');
            const episode = (match[3] || match[5] || '').padStart(2, '0');
            
            // Isolate the episode title by removing the series name and the SE pattern
            let episodeTitle = cleaned.replace(new RegExp(seriesName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi'), '');
            episodeTitle = episodeTitle.replace(sePattern, '').trim();
            episodeTitle = episodeTitle.replace(/^-+\s*|^\s*-\s*/, '').trim(); // Clean up leading separators
            
            return `S${season} E${episode} - ${episodeTitle || 'Episode ' + parseInt(episode, 10)}`;
        }

        // Fallback for titles without a clear S/E pattern
        return cleanTitleForSearch(rawTitle).replace(new RegExp(seriesName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi'), '').trim();
    }

    function extractSeriesNameFromTitle(title) {
        if (!title) return null;
        
        const knownSeries = ["Fawlty Towers", "South Park"];
        for(const series of knownSeries) {
            if (title.toLowerCase().includes(series.toLowerCase())) {
                // Handle cases like "South Park Movie"
                if (title.toLowerCase().includes("movie") || title.toLowerCase().includes("bigger, longer & uncut")) {
                    return "South Park";
                }
                return series;
            }
        }

        if (title.includes('/')) {
            const parts = title.split('/');
            const potentialName = parts[0].trim();
            if (potentialName) return potentialName.replace(/[._]/g, ' ').trim();
        }

        const match = title.match(/^(.*?)(?:\s*S\d{1,2}[\s.]?E\d{1,3}|\s*\d{1,2}x\d{1,2}|\s*Season\s\d{1,2}\sEpisode\s\d{1,3})/i);
        if (match && match[1]) {
            return match[1].replace(/[._]/g, ' ').replace(/[-]$/, '').trim();
        }
        
        return null;
    }


    async function fetchMovieDetailsFromTMDB(originalTitle) {
        if (!TMDB_API_KEY) return null;
        const cleanedTitle = cleanTitleForSearch(originalTitle);
        if (!cleanedTitle) return null;

        const cacheKey = `tmdb_movie_${cleanedTitle.replace(/\s+/g, '-').toLowerCase()}`;
        if(hasConsent) {
            const cachedItem = localStorage.getItem(cacheKey);
            if (cachedItem) {
                const { timestamp, data } = JSON.parse(cachedItem);
                if ((Date.now() - timestamp < (24 * 60 * 60 * 1000)) && data && data.logo) {
                    return data;
                }
            }
        }

        const yearMatch = originalTitle.match(/[\[\(.\s](\d{4})[\]\).\s]/);
        const year = yearMatch ? yearMatch[1] : null;

        let searchUrl = `https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(cleanedTitle)}`;
        if (year) searchUrl += `&primary_release_year=${year}`;

        try {
            const response = await fetch(searchUrl);
            const data = await response.json();
            let result = null;
            if (data.results && data.results.length > 0) {
                const movie = data.results[0];
                const genre = movie.genre_ids.length > 0 ? TMDB_GENRE_MAP[movie.genre_ids[0]] : 'Uncategorized';
                const logo = movie.poster_path ? `https://image.tmdb.org/t/p/w200${movie.poster_path}` : null;
                result = { genre, logo, title: movie.title };
            }
            if(hasConsent) localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: result }));
            return result;
        } catch (error) {
            console.error('Error fetching from TMDB:', error);
            return null;
        }
    }

    async function fetchTvShowDetailsFromTMDB(seriesName) {
        if (!TMDB_API_KEY) return null;
        const cleanedName = cleanTitleForSearch(seriesName);
        const cacheKey = `tmdb_series_details_${cleanedName.replace(/\s+/g, '-').toLowerCase()}`;
        if(hasConsent) {
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
                const { timestamp, data } = JSON.parse(cached);
                if ((Date.now() - timestamp < (24 * 60 * 60 * 1000)) && data && data.logo) {
                    return data;
                }
            }
        }

        const searchUrl = `https://api.themoviedb.org/3/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(cleanedName)}`;
        try {
            const response = await fetch(searchUrl);
            const data = await response.json();
            let result = null;
            if (data.results && data.results.length > 0) {
                const show = data.results[0];
                const genres = show.genre_ids.slice(0, 2).map(id => TMDB_GENRE_MAP[id]).filter(Boolean);
                const genre = genres.length > 0 ? genres.join(' / ') : 'Uncategorized';
                const logo = show.poster_path ? `https://image.tmdb.org/t/p/w200${show.poster_path}` : null;
                result = { genre, logo, name: show.name };
            }
            if(hasConsent) localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: result }));
            return result;
        } catch (error) {
            console.error(`Error fetching TV show details for ${seriesName}:`, error);
            return null;
        }
    }

    async function injectRemotePlaylists() {
        const targetPlaylistName = 'Internet Archive ðŸ“ºðŸŽ¬';
        const targetPlaylist = BASE_PLAYLISTS.find(p => p.name === targetPlaylistName);
        if (!targetPlaylist || !targetPlaylist.isNested) return;

        // --- SERIES HANDLING ---
        const seriesSources = [
            'https://raw.githubusercontent.com/ab19902020/Comedy/main/Series.m3u',
            'https://raw.githubusercontent.com/ab19902020/Sp/main/Sp.m3u',
            'https://raw.githubusercontent.com/ab19902020/King/main/Kingofhill.m3u'
        ];
        
        let allSeriesChannels = [];
        for (const url of seriesSources) {
            try {
                const data = await fetchWithFallback(url);
                if (!data) continue;
                const { channels } = await parseM3U(data, targetPlaylistName);
                allSeriesChannels.push(...channels);
            } catch (e) {
                console.error(`Failed to inject series from ${url}`, e);
            }
        }
        
        const groupedSeries = {};
        for (const channel of allSeriesChannels) {
            let seriesName = channel.group;
            if (!seriesName || seriesName.toLowerCase() === 'uncategorized') {
                const extractedName = extractSeriesNameFromTitle(channel.title);
                if (extractedName) seriesName = extractedName;
            }
            
            const finalGroupName = seriesName || 'Uncategorized';
            if (!groupedSeries[finalGroupName]) groupedSeries[finalGroupName] = [];
            channel.group = finalGroupName; 
            groupedSeries[finalGroupName].push(channel);
        }

        for (const seriesName in groupedSeries) {
            if (seriesName === 'Uncategorized') continue;
            const details = await fetchTvShowDetailsFromTMDB(seriesName);
            const logo = details?.logo || null;
            if (logo) {
                groupedSeries[seriesName].forEach(channel => {
                    channel.logo = logo;
                    channel.title = cleanEpisodeTitle(channel.title, seriesName);
                });
            }
        }
        
        targetPlaylist.structure.Series = groupedSeries;

        // --- MOVIE HANDLING ---
        const moviesPlaylistUrl = 'https://raw.githubusercontent.com/ab19902020/Comedy/main/Movies.m3u';
        try {
            const data = await fetchWithFallback(moviesPlaylistUrl);
            const { channels: movieChannels } = await parseM3U(data, targetPlaylistName);

            const movieDetailPromises = movieChannels.map(async (channel) => {
                const details = await fetchMovieDetailsFromTMDB(channel.title);
                if (details) {
                    channel.group = details.genre || 'Uncategorized';
                    channel.logo = details.logo || channel.logo;
                    channel.title = details.title || cleanTitleForSearch(channel.title);
                } else {
                    channel.group = 'Uncategorized';
                }
                return channel;
            });

            const updatedMovieChannels = await Promise.all(movieDetailPromises);

            const moviesCategory = targetPlaylist.structure.Movies;
            Object.keys(moviesCategory).forEach(key => delete moviesCategory[key]);
            
            if (updatedMovieChannels.length > 0) moviesCategory['All Movies'] = updatedMovieChannels;
            
            updatedMovieChannels.forEach(channel => {
                const genre = channel.group;
                if (genre && genre !== 'Uncategorized') { 
                    if (!moviesCategory[genre]) moviesCategory[genre] = [];
                    moviesCategory[genre].push(channel);
                }
            });
        } catch (e) {
            console.error(`Failed to inject remote movies playlist from ${moviesPlaylistUrl}`, e);
        }
    }

    function checkCookieConsent() {
        const consent = localStorage.getItem('cookie_consent');
        if (consent === 'accepted') {
            hasConsent = true;
            loadUserData();
        } else if (consent === 'declined') {
            hasConsent = false;
        } else {
            elements.cookieConsentBanner.classList.remove('hidden');
        }
    }

    function loadUserData() {
        if (!hasConsent) return;
        favorites = JSON.parse(localStorage.getItem('iptv_favorites')) || [];
        customPlaylists = JSON.parse(localStorage.getItem('iptv_custom_playlists')) || [];
    }

    async function initialize() {
        checkCookieConsent();
        
        try {
            await injectRemotePlaylists();
        } catch (e) {
            console.error("Initialization failed during remote playlist injection:", e);
        }
        
        initializePlayers();
        setupAllPlaylists();
        renderPlaylistOptions(allPlaylists);
        
        populateFeaturedChannels();

        // --- Event Listeners ---
        elements.sourceSelectorButton.addEventListener('click', () => {
            elements.sourceSelectorDropdown.classList.toggle('hidden');
             if (!elements.sourceSelectorDropdown.classList.contains('hidden')) {
                const currentPlaylistName = elements.sourceSelectorText.textContent.trim();
                const options = Array.from(elements.playlistOptionsContainer.children);
                const selectedOption = options.find(opt => opt.textContent.includes(currentPlaylistName));
                if (selectedOption) {
                    selectedOption.scrollIntoView({ block: 'nearest' });
                }
            }
        });

        document.addEventListener('click', (e) => {
            if (!elements.sourceSelectorButton.contains(e.target) && !elements.sourceSelectorDropdown.contains(e.target)) {
                elements.sourceSelectorDropdown.classList.add('hidden');
            }
        });
        
        elements.playlistSearchInput.addEventListener('click', (e) => e.stopPropagation());

        elements.playlistSearchInput.addEventListener('input', e => {
            const searchTerm = e.target.value.toLowerCase().trim();
            const filtered = allPlaylists.filter(p => p.name.toLowerCase().includes(searchTerm));
            renderPlaylistOptions(filtered);
        });

        elements.searchInput.addEventListener('input', e => {
            clearTimeout(searchTimeout);
            const searchTerm = e.target.value.toLowerCase().trim();
            
            if (!searchTerm) {
                loadDataForSource(elements.sourceSelectorText.textContent.trim());
                return;
            }
            
            const filteredChannels = allChannelsInPlaylist.filter(c => c.title && c.title.toLowerCase().includes(searchTerm));
            populatePlaylistUI(filteredChannels, true);

            searchTimeout = setTimeout(() => {
                if (typeof gtag === 'function' && searchTerm.length > 2) {
                    gtag('event', 'search', {
                        'search_term': searchTerm
                    });
                }
            }, 1000); // Debounce search tracking
        });

        elements.addPlaylistBtn.addEventListener('click', () => {
            if(!hasConsent) {
                alert("Please accept the data policy to add custom playlists.");
                return;
            }
            elements.addPlaylistModal.classList.remove('hidden')
        });
        elements.cancelAddPlaylistBtn.addEventListener('click', () => elements.addPlaylistModal.classList.add('hidden'));
        elements.savePlaylistBtn.addEventListener('click', () => {
            if(!hasConsent) return;
            const name = elements.newPlaylistName.value.trim();
            const url = elements.newPlaylistUrl.value.trim();
            if(name && url) {
                if (typeof gtag === 'function') {
                    gtag('event', 'add_custom_playlist', {
                        'playlist_name': name
                    });
                     gtag('set', 'user_properties', {
                        'is_custom_playlist_user': true
                    });
                }
                customPlaylists.push({name, url, icon: 'ðŸ“', isCustom: true});
                localStorage.setItem('iptv_custom_playlists', JSON.stringify(customPlaylists));
                setupAllPlaylists();
                renderPlaylistOptions(allPlaylists);
                elements.newPlaylistName.value = '';
                elements.newPlaylistUrl.value = '';
                elements.addPlaylistModal.classList.add('hidden');
            } else {
                alert("Please provide both a name and a valid URL.");
            }
        });
        
        // Modal & Consent Listeners
        elements.aboutBtn.addEventListener('click', () => {
            if (typeof gtag === 'function') {
                gtag('event', 'view_about_modal');
            }
            elements.dmcaModal.classList.remove('hidden');
        });
        elements.feedbackBtn.addEventListener('click', () => {
            if (typeof gtag === 'function') {
                gtag('event', 'click_feedback_button');
            }
            window.location.href = "mailto:StreamsSpheretv@gmail.com?subject=Feedback for Streams Sphere Player";
        });
         elements.buyCoffeeBtn.addEventListener('click', () => {
            if (typeof gtag === 'function') {
                gtag('event', 'click_donation_link');
            }
        });
        elements.closeDmcaBtn.addEventListener('click', () => elements.dmcaModal.classList.add('hidden'));
        elements.dmcaModal.addEventListener('click', (e) => {
            if (e.target === elements.dmcaModal) {
                 elements.dmcaModal.classList.add('hidden');
            }
        });
        
        elements.privacyPolicyLink.addEventListener('click', (e) => {
            e.preventDefault();
            elements.dmcaModal.classList.remove('hidden');
        });

        elements.acceptCookiesBtn.addEventListener('click', () => {
            localStorage.setItem('cookie_consent', 'accepted');
            hasConsent = true;
            elements.cookieConsentBanner.classList.add('hidden');
            loadUserData();
            setupAllPlaylists(); // Refresh playlist object with custom lists
            renderPlaylistOptions(allPlaylists);
             if (typeof gtag === 'function') {
                gtag('event', 'consent_action', {'action': 'accept'});
            }
        });

        elements.declineCookiesBtn.addEventListener('click', () => {
            localStorage.setItem('cookie_consent', 'declined');
            hasConsent = false;
            elements.cookieConsentBanner.classList.add('hidden');
            if (typeof gtag === 'function') {
                gtag('event', 'consent_action', {'action': 'decline'});
            }
        });


        elements.playlistElement.addEventListener('click', handlePlaylistClick);

        elements.menuToggle.addEventListener('click', () => {
            if (typeof gtag === 'function') {
                gtag('event', 'toggle_mobile_menu');
            }
            elements.mobileOverlay.classList.toggle('hidden');
            elements.sidebar.classList.toggle('-translate-x-full');
        });
        
        elements.mobileOverlay.addEventListener('click', () => {
            elements.sidebar.classList.add('-translate-x-full');
            elements.mobileOverlay.classList.add('hidden');
        });

        // --- Video Progress Tracking ---
        elements.mainPlayer.addEventListener('timeupdate', () => {
            const duration = elements.mainPlayer.duration;
            const currentTime = elements.mainPlayer.currentTime;
            if (duration > 0 && !isNaN(duration)) {
                const progress = (currentTime / duration) * 100;
                const milestones = [25, 50, 75, 90];
                milestones.forEach(point => {
                    if (progress >= point && !videoProgressTracker[point]) {
                        videoProgressTracker[point] = true;
                         if (typeof gtag === 'function' && hasConsent) {
                            gtag('event', 'video_progress', {
                                'channel_title': elements.nowPlayingTitle.textContent,
                                'progress_percent': point
                            });
                        }
                    }
                });
            }
        });
        elements.mainPlayer.addEventListener('ended', () => {
            if (typeof gtag === 'function' && hasConsent) {
                gtag('event', 'video_complete', {
                    'channel_title': elements.nowPlayingTitle.textContent
                });
            }
        });

        const lastSourceName = hasConsent ? (localStorage.getItem('iptv_last_source') || 'Internet Archive ðŸ“ºðŸŽ¬') : 'Internet Archive ðŸ“ºðŸŽ¬';
        const lastSourcePlaylist = allPlaylists.find(p => p.name === lastSourceName) || allPlaylists[0];
        if (lastSourcePlaylist) {
            updateSourceSelectorButton(lastSourcePlaylist);
            loadDataForSource(lastSourceName);
        }
    }

    function handlePlaylistClick(event) {
        const favoriteBtn = event.target.closest('.favorite-btn');
        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(favoriteBtn);
            return;
        }

        const channelItem = event.target.closest('.channel-item');
        if (channelItem) {
            const currentUrl = channelItem.dataset.url;
            if (currentUrl === lastClickedUrl) {
                enterFullscreen();
                lastClickedUrl = null;
            } else {
                document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                channelItem.classList.add('active');
                loadStream(currentUrl);
                lastClickedUrl = currentUrl;
            }
        }
    }
    
    initialize();
});
</script>
<script type='text/javascript' src='//pl27581272.revenuecpmgate.com/71/b0/80/71b080ede7a4b324e33a506ce803a791.js'></script>
</body>
</html>


